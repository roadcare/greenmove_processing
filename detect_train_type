CREATE OR REPLACE FUNCTION public.detect_train_type(
    trip_id uuid,
    schema_name text DEFAULT 'public'::text,
    min_train_distance real DEFAULT 0.5,
    min_train_ratio real DEFAULT 0.5,
    min_metro_length_ratio real DEFAULT 1.2,
    min_train_speed real DEFAULT 15,
    distance_to_train real DEFAULT 150)
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    total_distance REAL;
    avg_speed REAL;
    train_length REAL := 0;
    total_train_length REAL := 0;
    start_train_distance REAL;
    end_train_distance REAL;
    start_closest_nature TEXT;
    end_closest_nature TEXT;
    sql_query TEXT;
BEGIN
    -- Early validation - get trip metadata first
    sql_query := format('SELECT "totalDistance", "avgSpeed" FROM %I.trip WHERE id = $1', schema_name);
    EXECUTE sql_query INTO total_distance, avg_speed USING trip_id;
    
    -- Early exit conditions
    IF total_distance IS NULL OR avg_speed IS NULL THEN
        RETURN 'NOT_TRAIN';
    END IF;
    
    IF total_distance <= min_train_distance OR avg_speed <= min_train_speed THEN
        RETURN 'NOT_TRAIN';
    END IF;
    
    -- Combined analysis: Calculate all distances and train coverage in ONE query
    sql_query := format('
        WITH trip_points AS (
            SELECT 
                td.timestamp,
                td.long,
                td.lat,
                ST_Transform(ST_SetSRID(ST_MakePoint(td.long, td.lat), 4326), 2154) as geom,
                -- Check if point is within any train buffer
                EXISTS (
                    SELECT 1 
                    FROM bdtopo.train_buffer tb 
                    WHERE ST_Within(
                        ST_Transform(ST_SetSRID(ST_MakePoint(td.long, td.lat), 4326), 2154), 
                        tb.geom
                    )
                ) as is_in_train,
                ROW_NUMBER() OVER (ORDER BY td.timestamp) as rn
            FROM %I."tripDetail" td
            WHERE td."tripId" = $1 AND td."isValid" = true            
            ORDER BY td.timestamp
        ),
        trip_endpoints AS (
            SELECT 
                (SELECT geom FROM trip_points WHERE rn = 1) as start_geom,
                (SELECT geom FROM trip_points WHERE rn = (SELECT MAX(rn) FROM trip_points)) as end_geom
        ),
        consecutive_in_train_segments AS (
            SELECT 
                p1.geom as geom1,
                p2.geom as geom2
            FROM trip_points p1
            JOIN trip_points p2 ON p2.rn = p1.rn + 1
            WHERE p1.is_in_train = true AND p2.is_in_train = true
        ),
        trip_intrain_points AS (
            SELECT 
                geom,
                ROW_NUMBER() OVER (ORDER BY timestamp) as train_rn
            FROM trip_points
            WHERE is_in_train = true
        ),
        all_train_segments AS (
            SELECT 
                p1.geom as geom1,
                p2.geom as geom2
            FROM trip_intrain_points p1
            JOIN trip_intrain_points p2 ON p2.train_rn = p1.train_rn + 1
        ),
        -- Calculate distances to train_segment (for both detection and classification logic)
        segment_distances AS (
            SELECT 
                ts.nature,
                ST_Distance(te.start_geom, ts.geom) as dist_to_start,
                ST_Distance(te.end_geom, ts.geom) as dist_to_end,
                ROW_NUMBER() OVER (ORDER BY ST_Distance(te.start_geom, ts.geom)) as start_rank,
                ROW_NUMBER() OVER (ORDER BY ST_Distance(te.end_geom, ts.geom)) as end_rank
            FROM trip_endpoints te
            CROSS JOIN bdtopo.train_segment ts
        )
        SELECT 
            -- Train detection data
            COALESCE(SUM(ST_Distance(cits.geom1, cits.geom2) / 1000.0), 0) as consecutive_train_length,
            (SELECT COALESCE(SUM(ST_Distance(geom1, geom2) / 1000.0), 0) FROM all_train_segments) as total_train_length,
            -- Use segment distances for both detection and classification
            (SELECT dist_to_start FROM segment_distances WHERE start_rank = 1) as start_dist,
            (SELECT dist_to_end FROM segment_distances WHERE end_rank = 1) as end_dist,
            (SELECT nature FROM segment_distances WHERE start_rank = 1) as start_nature,
            (SELECT nature FROM segment_distances WHERE end_rank = 1) as end_nature
        FROM consecutive_in_train_segments cits
    ', schema_name, schema_name);
    
    EXECUTE sql_query INTO 
        train_length, total_train_length, 
        start_train_distance, end_train_distance,
        start_closest_nature, end_closest_nature 
        USING trip_id;
    
    -- Log all calculated values
    RAISE NOTICE 'Trip ID: %, Total Distance: % km, Avg Speed: % km/h, Train Length: % km, Start Train Dist: % m, End Train Dist: % m, Start Nature: %, End Nature: %', 
        trip_id, total_distance, avg_speed, train_length, start_train_distance, end_train_distance, start_closest_nature, end_closest_nature;
    
    -- STEP 1: Apply train detection logic (using trains_buffer distances and coverage)
    IF train_length > (min_train_ratio * total_distance) THEN
        -- High train coverage: check minimum distance and average speed
        IF NOT (total_distance > min_train_distance AND avg_speed > min_train_speed) THEN
            RETURN 'NOT_TRAIN';
        END IF;
    ELSIF train_length < (min_train_ratio * total_distance) AND train_length > (min_metro_length_ratio * total_distance) THEN
        -- Medium train coverage: check start/end points proximity to train buffer AND average speed
        IF NOT (start_train_distance < distance_to_train AND end_train_distance < distance_to_train AND avg_speed > min_train_speed AND total_distance > min_train_distance) THEN
            RETURN 'NOT_TRAIN';
        END IF;
    ELSE
        -- Low train coverage: return NOT_TRAIN
        RETURN 'NOT_TRAIN';
    END IF;
    
    -- STEP 2: If we reach here, it's a confirmed train trip
    -- Apply classification logic (using same distances as detection)
    IF start_train_distance < end_train_distance THEN
        RETURN COALESCE(start_closest_nature, 'NOT_TRAIN');
    ELSE
        RETURN COALESCE(end_closest_nature, 'NOT_TRAIN');
    END IF;
    
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'Error in detect_train_type_dev for trip %: %', trip_id, SQLERRM;
        RETURN 'NOT_TRAIN';
END;
$BODY$;